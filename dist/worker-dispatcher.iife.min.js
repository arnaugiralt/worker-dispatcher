var version=function(t){"use strict";class e{constructor(t,e){this._id=t,this.message=e}}return t.Dispatcher=class{constructor(t){this._methods=t,self.addEventListener("message",this._onMessage.bind(this))}async dispatch(t,e){const s=this._methods[t];if(!s)throw new Error(`Method "${t}" not registered`);return s(e,this)}register(t,e){let s;switch(typeof e){case"function":s=e;break;case"string":try{if(s=new Function("return "+e)(),"function"==typeof s)break}catch(t){throw t}default:throw new Error("Unsupported function type. Pass either a function or a stringified function")}this._methods[t]=s}unregister(t){delete this._methods[t]}async _onMessage(t){const{message:e,_id:s}=t.data,[r,i]=await this._act(e);postMessage([s,r,i])}async _act({type:t,method:e,payload:s}){try{let r;switch(t){case"dispatch":r=await this.dispatch(e,s);break;case"register":r=this.register(e,s);break;case"unregister":r=this.unregister(e);break;default:throw new Error("Unsupported action type")}return[void 0,r]}catch(t){return[t,void 0]}}},t.WorkerWrapper=class{constructor(t){this._idx=0,this._worker=t,this._callbacks={},this._initialise()}async dispatch(t,e){return this.$send({type:"dispatch",method:t,payload:e})}async register(t,e){if("fucntion"!=typeof e)throw new Error("Second parameter must be a function");const s=e.toSring();return this.$send({type:"register",method:t,payload:s})}async unregister(t){return this.$send({type:"register",method:t})}$send(t){this._idx++;const s=this._idx,r=new e(s,t);return new Promise((t,e)=>{this._callbacks[s]=(s,r)=>{s?e(new Error(s.message)):t(r)},this._worker.postMessage(r)})}_initialise(){this._worker.addEventListener("message",t=>{this._onMessage(t)})}_onMessage(t){const e=t.data;if(!Array.isArray(e)||3!==e.length)return;const[s,r,i]=e,n=this._callbacks[s];n&&(delete this._callbacks[s],n(r,i))}},t}({});
