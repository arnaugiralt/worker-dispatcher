var version=function(e){"use strict";class t{constructor(e,t){this._id=e,this.message=t}}return e.Dispatcher=class{constructor(e){this._methods=e,this._initListeners()}async dispatch(e,t){const s=this._methods[e];if(!s)throw new Error(`Method "${e}" not registered`);return s(t,this)}register(e,t){let s;switch(typeof t){case"function":s=t;break;case"string":s=new Function("return "+serializedFunc)();break;default:throw new Error("Unsupported function type. Pass either a function or a stringified function")}this._methods[e]=s}unregister(e){delete this._methods[e]}_initListeners(){const e=async({type:e,method:t,payload:s})=>{try{let r;switch(e){case"dispatch":r=await this.dispatch(t,s);break;case"register":this.register(t,s);break;case"unregister":this.unregister(t);break;default:throw new Error("Unsupported action type")}return[void 0,r]}catch(e){return[e,void 0]}};self.addEventListener("message",async t=>{const{message:s,_id:r}=t.data,[i,n]=await e(s);postMessage([r,i,n])})}},e.WorkerWrapper=class{constructor(e){this._idx=0,this._worker=e,this._callbacks={},this._initialise()}async dispatch(e,t){return this.$send({type:"dispatch",method:e,payload:t})}async register(e,t){if("fucntion"!=typeof t)throw new Error("Second parameter must be a function");const s=t.toSring();return this.$send({type:"register",method:e,payload:s})}async unregister(e){return this.$send({type:"register",method:e})}$send(e){this._idx++;const s=this._idx,r=new t(s,e);return new Promise((e,t)=>{this._callbacks[s]=(s,r)=>{s?t(new Error(s.message)):e(r)},this._worker.postMessage(r)})}_initialise(){this._worker.addEventListener("message",e=>{this._onMessage(e)})}_onMessage(e){const t=e.data;if(!Array.isArray(t)||3!==t.length)return;const[s,r,i]=t,n=this._callbacks[s];n&&(delete this._callbacks[s],n(r,i))}},e}({});
